<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SlowDown Algorithmic Regularization (SDAR): Introduction</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SlowDown Algorithmic Regularization (SDAR)
   </div>
   <div id="projectbrief">Algorithmic Regularization with slowdown method for integrating few-body motions</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Introduction </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="Algorithm"></a>
Algorithm</h1>
<p>The slow-down time-transformed explicit symplectic method (SDAR) combines the benefit of the symplectic integrator which conserves the Hamiltonian and angular momentum and the high efficiency of the slow-down method to handle the long-term evolution of hierarchical systems and close encounters. The details of the algorithm can be found in Wang, Nitadori &amp; Makino (2020). Here the idea is briefly introduced.</p>
<p>The slow-down method is introduced by <a href="http://adsabs.harvard.edu/abs/1996CeMDA..64..197M">Mikkola &amp; Aarseth (1996)</a>. For a perturbed binary, by artificially slowing down the orbital motion (scaling the time) while keeping the orbital parameters unchanged, the external perturbation is effectively enlarged. In such case, the effect of perturbation on one binary orbit can represent the average effect of several orbits. When the perturbation is weak, this method can properly approximate the secular evolution.</p>
<p>The symplectic integrator can conserve the Hamiltonian and the angular momentum of a system. Thus it is very suitable for simulating the long-term evolution of a system. However, it requires a constant integration step. In the classical symplectic method, time step, \( \mathrm{d} t \), is also the integration step, \( \mathrm{d} s \). This leads to a low efficiency in integrating an eccentric Kepler orbit. In order to be accurately enough, \( \mathrm{d} t \) has to be fixed to the smallest value determined at the pericenter. The solution is to apply a time transformation, \(\mathrm{d} t=g \mathrm{d} s\), which decouples \(\mathrm{d} s\) and \(\mathrm{d} t\) with a function \(g\) (see <a href="http://www.sciencedirect.com/science/article/pii/S0168927497000615">Hairer, 1997 </a>). Thus, \( \mathrm{d} t \) can vary to avoid the issue of low efficiency while \( \mathrm{d} s \) is fixed to keep the symplectic property. This method can be described by the extended phase space Hamiltonian:</p>
<p>(1) \( \Gamma(\mathbf{P},\mathbf{Q}) = H&#39;(\mathbf{P},\mathbf{Q}) \frac{d t}{d s} = g(\mathbf{Q},\mathbf{P}) (H(\mathbf{p},\mathbf{q},t) + Pt) \)</p>
<p>where \( H(\mathbf{p},\mathbf{q},t) \) is the standard Hamiltonian. The extended phase-space vector, \( (\mathbf{P},\mathbf{Q}) \), is defined by the standard coordinate and momentum pair \((\mathbf{p},\mathbf{q})\) with an additional pair of the coordinate, \( t \), and the conjugate momentum, \( Pt = - H(\mathbf{p},\mathbf{q},0) \) (negative initial Hamiltonian).</p>
<p>The equation of motion with the differential on \( s \) describe the symplectic map in the extended phase-space. The disadvantage is that the time transformation usually results in an inseparable Hamiltonian and only the expensive implicit integrator can be used. <a href="http://adsabs.harvard.edu/abs/1999MNRAS.310..745M">Mikkola &amp; Tanikawa (1999)</a> and <a href="http://adsabs.harvard.edu/abs/1999AJ....118.2532P">Preto &amp; Tremaine (1999)</a> find a solution by defining a specific type of time transformation function:</p>
<p>(2) \( g(\mathbf{Q},\mathbf{P}) = \frac{f(T(\mathbf{P})) - f(-U(\mathbf{Q}))}{T(\mathbf{P}) + U(\mathbf{Q})} \)</p>
<p>that the Hamiltonian can be written in a separable style, in order to use the explicit symplectic integrator. Especially, for an isolated binary system, if \( f(x) = log(x) \), so that \(\mathrm{d} t \approx \mathrm{d} s/ |U|\), where \(|U|\) is the absolute value of the binary potential energy (similar like the Burdet-Heggie time transformation), the integrator behaviors dramatically well for the Kepler orbit, i.e., the numerical trajectory follows the exact one with a phase error of time.</p>
<h2><a class="anchor" id="H_sec"></a>
Hamiltonian in Extended Phase Space</h2>
<p>Defining the general coordinates as \( \mathbf{q} = \{q_i\}, (i=1,n) \) with freedom of \(n\) and corresponding general momentums ad \( \mathbf{p} \), The Hamiltonian equations is:</p>
<p>(1) \( \frac{d \mathbf{q}}{d t} = \frac{\partial H}{\partial \mathbf{p}}\); \( \frac{d \mathbf{p}}{d t} = - \frac{\partial H}{\partial \mathbf{q}} \)</p>
<p>Here the dt is used as a differetial varaible. For the propuse as we discussed above, we want to use a new variable \(s\) replacing the function of time \(t\). In this case, the time is treated as a new general coordinate. And the corresponding time momentum \(Pt\) should be also added.</p>
<p>We extend the coordiantes to \( \mathbf{Q} = (t, \mathbf{q}) \) and the momentums to \( \mathbf{P} = (Pt, \mathbf{p})\) with total freedom of \(2(n+1)\).</p>
<p>The new Hamiltonian \(H&#39;\) should also satisfy the Hamiltonian equations (1). Especially for \((t, Pt)\), we can get:</p>
<p>(2) \( \frac{d t}{d t} = \frac{\partial H&#39;}{\partial Pt} = 1 \); \( \frac{d Pt}{d t} = - \frac{\partial H&#39;}{\partial t} = - \frac{\partial H}{\partial t}\)</p>
<p>From first equation of (2), we find the \(H&#39;\) linearly depend on \(Pt\), thus \(H&#39;\) can be the form as \( H&#39; = H + Pt \). The second equation indicates that the time evolution of \(Pt\) is equal to the negative energy change of the system. Thus the value of \(Pt\) at the time \(t\) can be \(-H(t)\).</p>
<p>We want to write Hamiltonian equations with new differetial variable \( ds\). Defining \( g(\mathbf{Q},\mathbf{P}) = \frac{dt}{ds} \), we can rewrite (1) with \(ds\) and extended coordinates \((\mathbf{Q}, \mathbf{P})\) as:</p>
<p>(3) \( \frac{d \mathbf{Q}}{d s} = g(\mathbf{Q},\mathbf{P}) \frac{\partial H&#39;}{\partial \mathbf{P}} \); \( \frac{d \mathbf{P}}{d s} = - g(\mathbf{Q},\mathbf{P}) \frac{\partial H&#39;}{\partial \mathbf{Q}} \)</p>
<p>However, we need to have the Hamiltonian equations the same form as original, thus we need to find another Hamiltonian \(\Gamma(\mathbf{P},\mathbf{Q})\) that satisfy the Hamiltonian equations:</p>
<p>(4) \( \frac{d \mathbf{Q}}{d s} = \frac{\partial \Gamma}{\partial \mathbf{P}} \); \( \frac{d \mathbf{P}}{d s} = -\frac{\partial \Gamma}{\partial \mathbf{Q}} \)</p>
<p>To find correct \(\Gamma(\mathbf{P},\mathbf{Q})\), we go back to the Principle of least action which is used to derive the Lagrangian equations. The relation between (standard) Hamiltonian \(H(\mathbf{p},\mathbf{q},t)\) and Lagrangian \(L(\mathbf{p},\mathbf{q},t)\) is</p>
<p>(5) \( H(\mathbf{p},\mathbf{q},t) = \sum_{i=1}^n p_i \dot{q_i} - L(\mathbf{p},\mathbf{q},t) \)</p>
<p>The Principle of least action require the action</p>
<p>(6) \( S = \int_{t_1}^{t_2} L(\mathbf{p},\mathbf{q},t) dt = \int_{t_1}^{t_2} \left[ \sum_{i=1}^n p_i \dot{q_i} - H(\mathbf{p},\mathbf{q},t) \right] dt \)</p>
<p>should take the mimimum path, thus any function variation \( \delta S \) should makes \( S + \delta S\) increase. Thus when \( \delta L(\mathbf{p},\mathbf{q},t) = 0 \), this condition is satisfied. This leads to the Lagrangian equations and also the Hamitonian equations.</p>
<p>Here the integration takes from \( t_1 \) to \( t_2 \) and the time is used as integration variable. Now we treat \((t, Pt)\) as new coordinate and momemtum, \(H&#39;\) as new Hamitonian, and use \(s\) as new integration variable. Then \(S\) can be rewrited as:</p>
<p>(7) \( S = \int_{s_1}^{s_2} \left[ \sum_{i=1}^n p_i \frac{d q_i} {d s} + Pt \frac{d t}{d s} - (H(\mathbf{p},\mathbf{q},t) + Pt) \frac{d t}{d s} \right] ds = \int_{s_1}^{s_2} \left[ \sum_{i=1}^{n+1} P_i \frac{d Q_i}{d s} - H&#39;(\mathbf{P},\mathbf{Q}) \frac{d t}{d s}\right] ds \)</p>
<p>It is obvious that when</p>
<p>(8) \( \Gamma(\mathbf{P},\mathbf{Q}) = H&#39;(\mathbf{P},\mathbf{Q}) \frac{d t}{d s} = g(\mathbf{Q},\mathbf{P}) (H(\mathbf{p},\mathbf{q},t) + Pt) \)</p>
<p>The formula (7) become the same form as (6). Then with Principle of least action, the Hamiltonian equation (4) can be derived. We call the \( \Gamma(\mathbf{P},\mathbf{Q}) \) is the Hamiltonian in the extended phase space \( (\mathbf{P},\mathbf{Q}) \)</p>
<p>The Hamiltonian in extended phase space \(\Gamma\) is also useful for analyzing the systems where Hamiltonian \(H\) explicitly depends on time and is not conserved. Since time become a coordinate in \(\Gamma\), \(\frac{\partial \Gamma}{\partial s}\) is zero thus \( \Gamma\) become conserved quantity. The method dealing with closed system can be used with Hamiltonian in extended phase space.</p>
<h2><a class="anchor" id="T_sec"></a>
Time transformation for Separable Hamiltonian</h2>
<p>With the Hamiltonian in extended phase space, we can integrate the equation of motions with step \( ds \) by choosing a kind of \(g(\mathbf{Q},\mathbf{P})\). If we choose a \(g(\mathbf{Q},\mathbf{P})\) that makes the Hamiltonian \(\Gamma(\mathbf{Q},\mathbf{P})\) separable for \(P\) and \(Q\):</p>
<p>(9) \( \Gamma(\mathbf{Q},\mathbf{P}) = a(\mathbf{P}) + b(\mathbf{Q}) \)</p>
<p>Then explicit Leapfrog (SIA) integration method can be used. Preto &amp; Tremaine (1999) suggests to use</p>
<p>(10) \( g(\mathbf{Q},\mathbf{P}) = \frac{f(T(\mathbf{P})) - f(-U(\mathbf{Q}))}{T(\mathbf{P}) + U(\mathbf{Q})} \)</p>
<p>where \( T(\mathbf{P}) = T(\mathbf{p}) + Pt \) is the extended kinetic energy and \( U(\mathbf{Q}) = U(\mathbf{q},t) \) is the extended potential energy.</p>
<p>The Hamiltonian becomes separable:</p>
<p>(11) \( \Gamma = f(T(\mathbf{P})) - f(-U(\mathbf{Q})) \)</p>
<p>Then the equation of motions are:</p>
<p>(12) \( \frac{d \mathbf{q} }{d s} = f&#39;(T(\mathbf{p})+Pt) \frac{\partial T(\mathbf{p})}{\partial {\mathbf{p}}} \); \( \frac{d t }{d s} = f&#39;(T(\mathbf{p})+Pt) \); \( \frac{d \mathbf{p} }{d s} = f&#39;(-U(\mathbf{q},t)) \frac{\partial U(\mathbf{q},t)}{\partial {\mathbf{q}}} \); \( \frac{d Pt}{d s} = f&#39;(-U(\mathbf{q},t)) \frac{\partial U(\mathbf{q},t)}{\partial {\mathbf{t}}} \);</p>
<p>where \( f&#39;(x) = \frac{d f(x)}{d x} \).</p>
<p>Since \(Pt = -H(t)\), \(H&#39;=H+Pt = T(\mathbf{P}) + U(\mathbf{Q}) = 0 \). Thus during integration, \(T(\mathbf{P}) \approx -U(\mathbf{Q}) \). This requires \( f(T(\mathbf{P})) - f(-U(\mathbf{Q})) \approx 0 \). With Taylor expansion, we can obtain:</p>
<p>(13) \( f(T(\mathbf{P})) = f(-U(\mathbf{Q})) + \left[T(\mathbf{P}) + U(\mathbf{Q})\right] f&#39;(-U(\mathbf{Q})) + O\left[T(\mathbf{P}) + U(\mathbf{Q})\right]^2 \)</p>
<p>Thus</p>
<p>(14) \( g(\mathbf{Q},\mathbf{P}) \approx f&#39;(-U(\mathbf{Q})) \)</p>
<h3><a class="anchor" id="logH_sec"></a>
Logarithmic Hamintonian method (LogH)</h3>
<p>Mikkola &amp; Tanikawa (1999) and Preto &amp; Tremaine (1999) suggest to use the function \( f(x) = \log{x} \) (Logarithmic Hamintonian method). In this case, the time transformation based on (14) is:</p>
<p>(15) \( g(\mathbf{Q},\mathbf{P}) \approx \frac{1}{-U(\mathbf{Q})} \)</p>
<p>Then the equation of motions can be written as:</p>
<p>(16) \( \frac{d \mathbf{q} }{d s} = \frac{1}{T(\mathbf{p})+Pt} \frac{\partial T(\mathbf{p})}{\partial {\mathbf{p}}} \); \( \frac{d t }{d s} = \frac{1}{T(\mathbf{p})+Pt} \); \( \frac{d \mathbf{p} }{d s} = \frac{1}{-U(\mathbf{q},t)} \frac{\partial U(\mathbf{q},t)}{\partial {\mathbf{q}}} \); \( \frac{d Pt}{d s} = \frac{1}{-U(\mathbf{q},t)} \frac{\partial U(\mathbf{q},t)}{\partial t} \);</p>
<p>For the point mass systems with Newtonian gravity</p>
<p>(17) \( T(\mathbf{p}) = \sum_{i=1}^{n} \frac{\mathbf{p_i}^2}{2m} \); \( U(\mathbf{q},t) = - \sum_{i&lt;j,i=1,j=1}^{i\rightarrow n,j\rightarrow n} \frac{G m_i m_j}{|\mathbf{q_i}-\mathbf{q_j}|} \)</p>
<p>where G is gravitational constant and \( m_i, m_j \) are masses of point-mass particles.</p>
<p>From (17) we see \( \frac{d Pt}{d s} = 0 \). This is only for the isolated system. If the system has external force from perturbers or external potential. The energy of system ( \(-Pt\)) may not be conserved any more. Thus the energy change should be added into \(Pt\) during the integration.</p>
<p><a href="http://adsabs.harvard.edu/abs/2002CeMDA..84..343M">Mikkola &amp; Aarseth (2002)</a> introduced a modified version of time transformed symplectic method. Instead of calculating \(T(\mathbf{P})\), one can also define a variable,</p>
<p>(18) \( u = \int \frac{\partial U(\mathbf{q})}{\partial \mathbf{q}} \cdot \frac{\mathrm{d} \mathbf{q}}{\mathrm{d} t} \)</p>
<p>Then \( f&#39;(u) = f&#39;(T(\mathbf{P})) \). The equation of motion has the form:</p>
<p>(19) \( \frac{d \mathbf{q} }{d s} = \frac{1}{u} \frac{\partial T(\mathbf{p})}{\partial {\mathbf{p}}} \); \( \frac{d t }{d s} = \frac{1}{u} \); \( \frac{d \mathbf{p} }{d s} = \frac{1}{-U(\mathbf{q})} \frac{\partial U(\mathbf{q})}{\partial {\mathbf{q}}} \); \( \frac{d u}{d s} = \frac{1}{-U(\mathbf{q})} \frac{\partial U(\mathbf{q})}{\partial \mathbf{q}} \cdot \frac{\langle \mathbf{p} \rangle} {m} \);</p>
<h1><a class="anchor" id="code_sec"></a>
Implementation</h1>
<p>We implememted the SDAR method in this code by using the C++ programming Language. This code contains three modules: <a class="el" href="namespaceAR.html" title="Algorithmic regularization (time transformed explicit symplectic integrator) namespace.">AR</a>, <a class="el" href="namespaceH4.html">H4</a> and <a class="el" href="namespaceCOMM.html">COMM</a>.</p>
<p>The <a class="el" href="namespaceAR.html" title="Algorithmic regularization (time transformed explicit symplectic integrator) namespace.">AR</a> module provides an c++ integrator class <a class="el" href="classAR_1_1TimeTransformedSymplecticIntegrator.html" title="Time Transformed Symplectic integrator class for a group of particles.">AR::TimeTransformedSymplecticIntegrator</a>. It is a template class that depends on the class types of particle, interaction, perturbation and extra-information. <a class="el" href="classAR_1_1TimeTransformedSymplecticManager.html" title="Time Transformed Symplectic integrator manager.">AR::TimeTransformedSymplecticManager</a> is the manager class contain the pair interaction class and parameters to control the integration. One manager can be shared with multiple integrators.</p>
<p>The <a href="http://www.sciencedirect.com/science/article/pii/0375960190900923">Yoshida high-order symplectic method </a> is used together with the SDAR method. The drift-kick-drift mode must be used as the base of the 2nd order method for a high accuracy. The reason is described in Preto &amp; Tremaine (1999) and <a href="https://github.com/nitadori/Grad4th/blob/master/logH.pdf">Nitadori (2018) </a>.</p>
<p>The Hermite module provides an c++ integrator class <a class="el" href="classH4_1_1HermiteIntegrator.html" title="Hermite integrator class.">H4::HermiteIntegrator</a> that combine a 4th-order Hermite method with block time steps and multiple SDAR integrators. The former deals with the global particle system and the latter handle the compact subgroups in the system. The criterion to determine the members in subgroups are based on a distance given by the input parameters. <a class="el" href="classH4_1_1HermiteManager.html" title="Hermite manager class.">H4::HermiteManager</a> provides the pair interaction and parameters to control the Hermite integration.</p>
<p>The <a class="el" href="namespaceCOMM.html">COMM</a> module provides the basic data type and the tool to construct a Hierarchical (Kepler) binary tree for a group of particles. It is used to identify the subgroups in the Hermite integrator and to calculate the slow-down factor in the <a class="el" href="namespaceAR.html" title="Algorithmic regularization (time transformed explicit symplectic integrator) namespace.">AR</a> integrator.</p>
<h1><a class="anchor" id="sample_sec"></a>
Use sample codes</h1>
<p>To help the users to understand how to use the library, a few sample codes are provided in the sample directory. In the three subdirectory: <a class="el" href="namespaceAR.html" title="Algorithmic regularization (time transformed explicit symplectic integrator) namespace.">AR</a>, Hermite and Kepler, users can find the instance of code. For example, AR/ar.cxx is an SDAR integrator, that read a particle set and integrate the system to a given time or a number of steps. Similarly, Hermite/hermite.cxx is a Hermite integrator. In Kepler subdirectory, keplerorbit.cxx provides a transformation tool to calculate the Kepler orbital paramters from a particle pair and vice versa. Keplertree.cxx can construct the Hierarchical Kepler binary tree for a given particle set and vice versa.</p>
<p>Use commander "make" in each subdirectory to create the excutable files and use the sample code. For example, in <a class="el" href="namespaceAR.html" title="Algorithmic regularization (time transformed explicit symplectic integrator) namespace.">AR</a> after make, four ar.** binary files are created. For any of them (e.g. ar.logh), use</p>
<p>ar.logh -h</p>
<p>will output the help and describe the input parameters to use the integrator. Similary, -h options can be used to all other sample codes. Please refer to the help information for the details of the usage of the sample codes.</p>
<h1><a class="anchor" id="library_sec"></a>
For developers</h1>
<p>Each c++ class in this library are detailed described in the documantion in order to help the users to develop their own N-body codes. The developers can use the functions provided in three namespaces: <a class="el" href="namespaceAR.html" title="Algorithmic regularization (time transformed explicit symplectic integrator) namespace.">AR</a>, <a class="el" href="namespaceH4.html">H4</a> and <a class="el" href="namespaceCOMM.html">COMM</a> located in three subdirectories in src. The sample directory provide the good examples showing how to use the code as a library.</p>
<h2><a class="anchor" id="ar_sec"></a>
AR module</h2>
<p>The <a class="el" href="namespaceAR.html" title="Algorithmic regularization (time transformed explicit symplectic integrator) namespace.">AR</a> namespace contains the template classes to construct the SDAR integrator. The major class that contains the particle data and the integration functions is <a class="el" href="classAR_1_1TimeTransformedSymplecticIntegrator.html" title="Time Transformed Symplectic integrator class for a group of particles.">AR::TimeTransformedSymplecticIntegrator</a>. It depends on five template types:</p><ul>
<li>particle type of members</li>
<li>particle type of the center-of-the-mass of the particle group</li>
<li>perturber class that handles the external perturbation to the members</li>
<li>interaction class that defines the pair interaction and the method to calculate slow-down perturbation and timescales</li>
<li>information class that contains user-defined information, it should inherit from the defaulted <a class="el" href="classAR_1_1Information.html" title="A class contains information (e.g. parameters, binary tree, indices) about the particle group.">AR::Information</a> class.</li>
</ul>
<p>To create a SDAR integrator, it is necessary to provide these five types. Thus, the user should first define the particle type. The example is shown in the class Particle in sample/AR/particle.h. A few necessary members and member functions should be defined as shown in the sample, please follow the link to check the details.</p>
<p>The particle type of the center-of-the-mass can be different from the type of the member. One example is shown in the sample/Hermite/hermite.cxx.</p>
<p>If interaction between the members of the particle groups and the external sources is needed. In the sample of ar.cxx, there is no external perturbation, thus the class Perturber defined in sample/AR/perturber.h is emplty with only a few necessary IO functions</p>
<p>The interaction class is important and necessary to be provided to calculate the pair interaction between the members. Also the interaction between perturbers and members also also defined in this class. The example Interaction in sample/AR/interaction.h shows the necessary member functions used in the SDAR method. For the SDAR method, it is also required to calculate the time tranformation function together with the force and potential calculations. Besides, if the slow-down method is used, the slow-down inner force and perturbation should also be calculated to calculate the next slow-down factor.</p>
<p>The information class should inherit from <a class="el" href="classAR_1_1Information.html" title="A class contains information (e.g. parameters, binary tree, indices) about the particle group.">AR::Information</a>. The latter contain the method to calculate the integration step size based on the Kepler orbital information of the system. Also it contains the binary tree of the particle members, which records the hierarchical relations between particles and the corresponding Kepler orbital elements.</p>
<p>Once all these 5 types are defined. Use </p><pre class="fragment">AR::TimeTransformedSymplecticIntegrator&lt;Particle, Particle, Perturber, Interaction, Information&lt;Particle,Particle&gt;&gt; sym_int;
AR::TimeTransformedSymplecticManager&lt;Interaction&gt; manager;
</pre><p>to create the integrator ARint and the manager. A few parameters in the manager should be initialized before the integration. Please check the link of <a class="el" href="classAR_1_1TimeTransformedSymplecticManager.html" title="Time Transformed Symplectic integrator manager.">AR::TimeTransformedSymplecticManager</a> for details.</p>
<p>There are two way to assign a particle group to the integrator. use </p><pre class="fragment">sym_int.particles.setMode([COMM::ListMode::[types]);
</pre><p>to set the mode:</p><ul>
<li><a class="el" href="namespaceCOMM.html#aa0ca1c24dcb00331c6dca89a0a188fe3af5ddaf0ca7929578b408c909429f68f2">COMM::ListMode::local</a> indicates that the particle data is stored in the local allocated array in particles.</li>
<li><a class="el" href="namespaceCOMM.html#aa0ca1c24dcb00331c6dca89a0a188fe3a2a304a1348456ccd2234cd71a81bd338">COMM::ListMode::link</a> indicates that the particle data is not stored in particles but only the address pointing to an existed particle data array is stored.</li>
<li><a class="el" href="namespaceCOMM.html#aa0ca1c24dcb00331c6dca89a0a188fe3a12cba3ee81cf4a793796a51b6327c678">COMM::ListMode::copy</a> indicates that the particle data are copied from an existed particle array and also the addresses to original particle are saved in order to writeback the data.</li>
</ul>
<p>After set mode, the particles can be added based on the mode. For example </p><pre class="fragment">sym_int.particles.setMode(COMM::ListMode::local);
sym_int.particles.readMemberAscii(fin);
</pre><p>will read the particle data from a std::fstream file IO fin.</p>
<p>The details of the mode can be found in <a class="el" href="classCOMM_1_1List.html" title="list class to store and manage a group of member">COMM::List</a>.</p>
<p>The center-of-the-mass can be calculated after all particle data are read. </p><pre class="fragment">sym_int.particles.calcCenterOfMass();
</pre><p>Before starting the integration, it is useful to construct the binary tree by using </p><pre class="fragment">sym_int.info.reserveMem(sym_int.particles.getSize());
sym_int.info.generateBinaryTree(sym_int.particles,manager.interaction.gravitational_constant);
</pre><p>The first line allocate the necessary memory space to store the binary tree. The second line generate the binary tree. The second argument is the gravitatinal constant, based on the units used in the particle data.</p>
<p>Then the initialization of integration will calculate the initial state of the system (e.g. energy and slow-down factor) </p><pre class="fragment">sym_int.initialIntegration(time_zero.value);
sym_int.info.calcDsAndStepOption(sym_int.slowdown.getSlowDownFactorOrigin(), manager.step.getOrder(), manager.interaction.gravitational_constant);
</pre><p>The second line estimate the initial step, see <a class="el" href="classAR_1_1Information.html" title="A class contains information (e.g. parameters, binary tree, indices) about the particle group.">AR::Information</a> for details.</p>
<p>Finally, the integration can be excuted by: </p><pre class="fragment">sym_int.integrateToTime(time);
</pre><p>which integrate the system to given time. If interruption function is triggered, the integration can break in the middle and return the binary tree address of the interrupted pair. See Interaction class for the interruption function. Instead of integrating to a given time, it can also only integrate one step by </p><pre class="fragment">sym_int.integrateTwoOneStep(sym_int.info.ds, time_table);
</pre><p>or </p><pre class="fragment">sym_int.integrateOneStep(sym_int.info.ds, time_table);
</pre><p>The first is the fast method to integrate two body system. The second is general for multiple systems.</p>
<p>The state of particles can be directly accessed by checking the sym_int.particles or write to std::ostream using the IO functions. The details of output is defined by users in the writeBinary, readBinary, writeAscii and ReadAscii functions in each class.</p>
<h2><a class="anchor" id="h4_sec"></a>
H4 module</h2>
<p>The way to use Hermite integrator is similar to the SDAR integrator. The users should provide the additional interaction class which define the interactions between <a class="el" href="namespaceAR.html" title="Algorithmic regularization (time transformed explicit symplectic integrator) namespace.">AR</a> members and Hermite members, and the corresponding perturber, information types for Hermite integrator.</p>
<p>To read the particle data, the subgroups that need SDAR methods can be pre-defined in the input data file. <a class="el" href="classH4_1_1HermiteIntegrator.html#aa1916dc7e970885940bd74ed52aa222c" title="Add group based on a configure file.">H4::HermiteIntegrator::readGroupConfigureAscii</a> function is used to read the configuration of the subgroups.</p>
<p>The intergration contain four steps (see hermite.cxx sample) </p><pre class="fragment">auto* bin_interrupt = h4_int.integrateGroupsOneStep();
h4_int.integrateSingleOneStepAct();
h4_int.adjustGroups(false);
h4_int.initialIntegration();
h4_int.sortDtAndSelectActParticle();
</pre><p>The first line integrate all subgroups using SDAR method, if interreupt appears, the address is returned. In such case, h4_int.integrateGroupsOneStep() should be called again until no new interruption appear. Then the single particles are integrated by Hermite method. After one step integration. <a class="el" href="classH4_1_1HermiteIntegrator.html#a4681b656dd42eae01d3d85e66ac55112" title="adjust groups">H4::HermiteIntegrator::adjustGroups</a> function checks the structure of the system and decide whether subgroups need to form or disrupt. H4::hermiteIntegrator::initialIntegration renews the system after the adjustment of groups. The finall step H4::hermiteIntegrator::sortDtAndSelectActParticle sorts the time steps of particles and determine the next active block step lists.</p>
<h2><a class="anchor" id="comm_sec"></a>
COMM module</h2>
<p>In src/Common, a few header files define the common tools used in <a class="el" href="namespaceAR.html" title="Algorithmic regularization (time transformed explicit symplectic integrator) namespace.">AR</a> and <a class="el" href="namespaceH4.html">H4</a> modules.</p><ul>
<li><a class="el" href="Float_8h.html">Float.h</a> defines the floating point type, if the QD library is used, high-precision floating point can be switched on.</li>
<li><a class="el" href="list_8h.html">list.h</a> define the allocateble array type list, used to manage the particle array.</li>
<li><a class="el" href="binary__tree_8h.html">binary_tree.h</a> defines the <a class="el" href="classCOMM_1_1BinaryTree.html" title="Binary tree cell.">COMM::BinaryTree</a> class that can be used to generate the binary tree of a particle group and <a class="el" href="classCOMM_1_1Binary.html" title="Binary parameter class.">COMM::Binary</a> class that can be used to transform particle pair to kepler orbits and vice versa.</li>
<li><a class="el" href="particle__group_8h.html">particle_group.h</a> is based on <a class="el" href="list_8h.html">list.h</a> and used as the particle data container for <a class="el" href="namespaceAR.html" title="Algorithmic regularization (time transformed explicit symplectic integrator) namespace.">AR</a> and <a class="el" href="namespaceH4.html">H4</a> methods. </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
